set pc, boot

;; BEGIN JUMP TABLE
:kern_return       		; 0x002
SET PC, PC         		; NOP (reserved)
:kern_strcmp 			; 0x003
SET PC, strcmp
:kern_startswith 		; 0x005
SET PC, startswith
:kern_strlen			; 0x007
SET PC, strlen
:kern_strcat			; 0x009
SET PC, strcat
:kern_print				; 0x00B
SET PC, print
:kern_printnl			; 0x00D
SET PC, printnl
:kern_printchar			; 0x00F
SET PC, printchar
:kern_newline			; 0x011
SET PC, newline
:kern_scroll			; 0x013
SET PC, scroll
:kern_clear		        ; 0x015
SET PC, clearScreen
:kern_vidmem            ; 0x017
DAT 0x8000
:kern_backspace         ; 0x018      DATs only use one word
SET PC, backspace
:kern_memcpy			; 0x01A
SET PC, memcpy
:kern_reserve           ; 0x01C
SET PC, reserve
:kern_malloc            ; 0x01E
SET PC, malloc
:kern_memset            ; 0x020
SET PC, memset
:kern_free              ; 0x22
SET PC, free
:kern_readline          ; 0x24
SET PC, readline

:kboffset dat 0x0
:fortyosmem dat 0x1000
:mempointer dat 0x6000
:loadingmsg dat "Loading 0x42c...", 0
:donemsg dat " done.", 0
:userspacemem dat 0x6000
:userspaceend dat 0x7fff
:ibufferbegin dat 0x5000
:inputbuffer dat 0x5000

:boot
    set a, [userspacemem]
    set b, [userspaceend]
    jsr set_initial_blocks

    set [kern_vidmem], 0x8000
    
    set a, loadingmsg
	jsr print

	set a, [fortyosmem]
	set b, fortytwoc
	set c, 1000 ; length
	jsr memcpy

    set a, donemsg
    jsr printnl

	set pc, 0x1000


; ===== STANDARD 0x42c LIBRARY ====
; char* readline(void) // reads one line from user input
:readline 
	set a, [kboffset]
	add a, 0x9000
	ife [a], 0   ; if there's no input...
		set pc, readline
	ife [a], 0xA ; enter
		set pc, readline_enter
	ife [a], 0x8 ; backspace
		set pc, readline_backspace

	set a, [a]
	jsr printchar

	set a, [inputbuffer]
	set b, [kboffset]
	add b, 0x9000
	set b, [b]
	jsr strcat
	add [inputbuffer], 1

	set a, [kboffset]
	add a, 0x9000
	set [a], 0
	
	add [kboffset], 1
	and [kboffset], 0xf ;; mod [kboffset], 0x10
	set pc, readline

    :readline_backspace
	sub [inputbuffer], 1	; delete last char
	set a, [inputbuffer]
	set [a], 0

        jsr backspace

	set a, [kboffset]
	add a, 0x9000
	set [a], 0
	set pc, readline
	
	:readline_enter
	    set a, [kboffset]
		add a, 0x9000
	    set [a], 0
	    set push, j
	    set a, [ibufferbegin]
	    jsr strlen
	    add a, 1                ; end space
	    set push, a
	    set b, 0x042c
	    jsr malloc
	    set j, a
	    set b, [ibufferbegin]
	    set c, pop
	    jsr memcpy
	    set [inputbuffer], 0x5000
	    jsr readline_reset_ibuffer
	    set a, j
	    set j, pop
	    set pc, pop
	 
	 :readline_reset_ibuffer
	    set push, a
	    set a, [inputbuffer]
	    set [a], 0
	    set a, pop
	    set pc, pop   
	    
	    
; void memset(void* dst, void* src, int words)
:memset                                             ; Credit for this function goes to Tobba/rmmh
  	SET PUSH, X
    SET X, SP
    SET SP, A
    ADD A, C

    AND C, 0x1f
    XOR C, 0x1f
    ADD C, 1
    ADD PC, C
      
    :memset_loop
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B
        SET POP, B

        IFN SP, A
        SET PC, memset_loop
      
    SET SP, X
    SET X, POP
    SET PC, POP

:reserve                                 ; ARGS: A -> start, B -> end
    set [mempointer], a
    set pc, pop

; void free(void* addr) 
:free
    sub a, 2 ; user gives the first allocated word, header is two words back  
    set [a], 0xffff ; free memory
    set push, a
    
    :free_check_forward
        add a, 1
        set b, [a]
        add a, b
        add a, 2 ; next header
        ife [a], 0xffff
            set pc, free_merge_forward
    
    :free_check_backwards
        set a, peek
        sub a, 1
        ifg a, [userspacemem]
            set pc free_check_backwards_continue
            
        set pc, free_end
    
    :free_check_backwards_continue
        ife [a], 0x0 ; if previous footer is empty
            set pc, free_end
        
        set b, [a]
        set a, b
        ifn [a], 0xffff
            set pc, free_end
            
        set peek, a ; the previous push is unnecesary
        add a, 1
        set b, [a]
        add a, b
        add a, 2 
                          
        set pc, free_merge_forward ; no need to check since we already know there's a blob of free memory there
        
    :free_merge_forward
        set [a], 0x0
        add a, 1
        set b, [a]
        set c, b ; previous block length
        set [a], 0x0
        add a, b
        ifn a, [userspaceend]
            add a, 1 ; footer of this block
        set b, pop
        set push, b ; we'll need it at the end
        set [a], b
        set a, b
        add a, 1
        set b, [a]
        add b, c
        add b, 3 ; considering overhead
        set [a], b
        set pc, free_end
    
    :free_end
        set a, pop
        set pc, pop

; void* malloc(int owner, int words)
:malloc
    set push, i
    set i, [mempointer]
    
    :malloc_loop
        ife [i], 0xffff
            set pc, malloc_found_free
        
        add i, 1
        add i, [i]
        add i, 2
        
        set pc, malloc_loop
    :malloc_found_free
        ife i, [userspacemem] ; beginning
            set pc, malloc_allocate
        
        add i, 1
        
        ife [i], a
            set pc, malloc_prepare
        ifg [i], a
            set pc, malloc_check_overhead
            
        add i, 1
        add i, [i] ; size of block
        
        set pc, malloc_loop    
        
    :malloc_check_overhead
        set push, b
        set b, [i]
        sub b, a
        ifg b, 3 ; plenty of space for overhead
            set pc, malloc_check_end
        
        sub i, 1
        set b, pop
        set [i], b ; it isn't worth dividing the space
        set push, i
        set pc, malloc_end
        
        :malloc_check_end
            set b, pop
            set pc, malloc_prepare    
        
    :malloc_prepare
        sub i, 1
        set pc, malloc_allocate
        
    :malloc_allocate
        set push, i
        set push, i
        set [i], b
        add i, 1
        set [i], a
        add i, 1
        add i, a
        set b, pop
        set [i], b ; header pointer
        
        add i, 1
        set a, i
        set b, [userspaceend]
        jsr set_initial_blocks
        set pc, malloc_end
           
    :malloc_end
        set a, pop
        add a, 2 ; real start of memory
        set i, pop
        set pc, pop
    
; void set_initial_blocks(void memstart, void memend)    
:set_initial_blocks
    set push, b
    set [a], 0xffff ; owner of free mem
    add a, 1
    sub b, a
    set [a], b      ; space available
    set b, pop
    sub a, 1
    set [b], a
    
    set pc, pop

:backspace
	sub [kern_vidmem], 1
	set a, 0
	jsr printchar
	sub [kern_vidmem], 1
	set pc, pop
; void memcpy(void* dst, void* src, int words)
:memcpy                                         ; Credit for this function goes to Tobba
    SET PUSH, J
    SET J, SP
      
    SET SP, B
    ADD B, C
  	
    SET PC, duff
      
    :loop
    IFE SP, B
    SET PC, end
      
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
	SET [A], POP
	ADD A, 0x01
    SET PC, loop
      
    :duff
    AND C, 0x7
    SHL C, 1
    ADD C, 6
    SUB PC, C
    
    :end
      
    SET SP, J
    SET J, POP
	SET PC, POP

; int startswith(char* arg1, char* arg2) // returns 0 if arg2 starts with arg1
:startswith
    set y, 0

    ife [a], 0
        set pc, startswith_end_success


    ife [a], [b]
        jsr checkzero

    ife y, 1
        set pc, startswith_end_false

    ifn [a], [b]
        set pc, startswith_end_false

    add a, 1
    add b, 1
    set pc, startswith

    :startswith_end_false
        set y, 1
        set pc, pop

    :startswith_end_success
        set y, 0
        set pc, pop

    :checkzero
        ife [a], 0
            set y, 1
        set pc, pop

; int strlen(char* str) // returns the length of str
:strlen                                         ; Creddit for this function goes to Tobba
  SET B, SP
  SET SP, A
  
  :strlen_loop
    IFE POP, 0
    SET PC, strlen_end
    
    IFE POP, 0
    SET PC, strlen_end
    
    IFE POP, 0
    SET PC, strlen_end
    
    IFE POP, 0
    SET PC, strlen_end
    
    SET PC, strlen_loop
  :strlen_end
    SET C, PUSH ; Decrease SP one
    SUB SP, A
    SET A, SP
    SET SP, B
    SET PC, POP

; int strcmp(char* arg1, char* arg2) // returns 0 if arg1 == arg2
:strcmp                                           ; Credit for this function goes to Tobba
    SET C, SP
    SET SP, B
    
    :strcmp_loop
    IFN [A], PEEK
        SET PC, strcmp_nonequal
    IFE POP, 0
        SET PC, strcmp_end
    IFN [1+A], PEEK
        SET PC, strcmp_nonequal
    IFE POP, 0
        SET PC, strcmp_end
    ADD A, 2
    SET PC, strcmp_loop
    
    :strcmp_nonequal
    SET A, [A]
    SUB A, PEEK
    SET SP, C
    SET PC, POP
    
    :strcmp_end
    XOR A, A
    SET SP, C
    SET PC, POP

; void strcat(char* dst, char what) // appends what to dst
:strcat
	set [a], b
	add a, 1
	add b, 1
	set [a], 0
	set pc, pop

; void printnl(char* str) // prints str with a newline
:printnl   ; shortcut
	jsr print
	jsr newline
	set pc, pop
; void print(char* str) // prints str
:print
	set i, a
	:doprint
		ife [i], 0
			set pc, pop
		set a, [i]
		jsr printchar
		add i, 1
		set pc, doprint

; void printchar(char what) // prints what
:printchar
	ifg [kern_vidmem], 0x817f ; end of vidmem
		jsr scroll
	set b, [kern_vidmem]
	bor a, 0xf000 ; color :D
	set [b], a
	add [kern_vidmem], 1
	set pc, pop

; void newline(void) // prints a new line
:newline
	set i, [kern_vidmem]
	mod i, 32 ; width
	set z, 32
	sub z, i
	add [kern_vidmem], z
	set pc, pop

; void scroll(void) // scrolls up a line
:scroll
	set push, x
	set push, z

	set x, 0x8000
	set z, 0x8020
	
	set push, j
	set j, sp			; nifty stack pointer abuse :P
	set sp, 0x8000
	
	:scroll_loop
		set pop, [z]
		set pop, [1+z]
		set pop, [2+z]
		set pop, [3+z]
		set pop, [4+z]
		set pop, [5+z]
		set pop, [6+z]
		set pop, [7+z]
		set pop, [8+z]
		set pop, [9+z]
		set pop, [10+z]
		set pop, [11+z]
		set pop, [12+z]
		set pop, [13+z]
		set pop, [14+z]
		set pop, [15+z]
		set pop, [16+z]
		set pop, [17+z]
		set pop, [18+z]
		set pop, [19+z]
		set pop, [20+z]
		set pop, [21+z]
		set pop, [22+z]
		set pop, [23+z]
		set pop, [24+z]
		set pop, [25+z]
		set pop, [26+z]
		set pop, [27+z]
		set pop, [28+z]
		set pop, [29+z]
		set pop, [30+z]
		set pop, [31+z] ; unrolled loop. So sue me :P
		
		add z, 32
		ifg z, 0x817f
			set pc, scroll_end
		set pc, scroll_loop

	:scroll_end
		set sp, j
		set j, pop
		set z, pop
		set x, pop
		set [kern_vidmem], 0x815f ; last line beginning
		set pc, pop

; void clearScreen(void) // clears the screen 
:clearScreen
	set i, sp
	set sp, [kern_vidmem]
		:clearScreen_loop
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		set push, 0
		ifg 0x8000, sp
			set pc, clearScreen_done
		set pc, clearScreen_loop

		:clearScreen_done
		set [kern_vidmem], 0x8000
		set sp, i
		set pc, pop
		
		
		
		
; HARDCODED OS (will be loaded from disc when IO is announced)
:fortytwoc .incbin "../bin/0x42c_trim.bin" LE
